import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
var NODE_TYPE;
(function (NODE_TYPE) {
    NODE_TYPE[NODE_TYPE["ELEMENT"] = 1] = "ELEMENT";
    NODE_TYPE[NODE_TYPE["TEXT"] = 3] = "TEXT";
})(NODE_TYPE || (NODE_TYPE = {}));
var useTextToVoice = function (_a) {
    var _b = _a === void 0 ? {} : _a, pitch = _b.pitch, rate = _b.rate, volume = _b.volume;
    var textContainerRef = useRef(null);
    var voiceTranscript = useRef('');
    var firstRenderRef = useRef(true);
    var _c = useState(''), textContent = _c[0], setTextContent = _c[1];
    var _d = useState(false), isSpeaking = _d[0], setIsSpeaking = _d[1];
    var synth = typeof window === 'undefined' ? null : window.speechSynthesis;
    var utterThis = useMemo(function () {
        if (typeof SpeechSynthesisUtterance === 'undefined') {
            return null;
        }
        return new SpeechSynthesisUtterance(textContent);
    }, [textContent]);
    var extractText = useCallback(function (element) {
        if (!element)
            return;
        // Check if the element has child nodes
        if (element.childNodes.length > 0) {
            // Loop through the child nodes
            element.childNodes.forEach(function (child) {
                if (child.nodeType === NODE_TYPE.TEXT) {
                    // If it's a text node (nodeType 3), add its text content to the result
                    voiceTranscript.current += child.textContent;
                }
                else if (child.nodeType === NODE_TYPE.ELEMENT) {
                    // If it's an element node (nodeType 1), recursively call the function
                    extractText(child);
                }
            });
        }
    }, []);
    if (utterThis) {
        utterThis.onerror = function (event) {
            console.log("An error has occurred with the speech synthesis: ".concat(event.error));
        };
        utterThis.onend = function () {
            setIsSpeaking(false);
        };
    }
    // get voices Web Speech API provided
    var voices = useMemo(function () { var _a; return (_a = synth === null || synth === void 0 ? void 0 : synth.getVoices()) !== null && _a !== void 0 ? _a : []; }, [synth]);
    var voiceNames = useMemo(function () { return voices.map(function (voice) { return voice.name; }); }, [voices]);
    useEffect(function () {
        if (firstRenderRef.current && textContainerRef) {
            var voiceContainer = textContainerRef.current;
            firstRenderRef.current = false;
            extractText(voiceContainer);
        }
        setTextContent(voiceTranscript.current);
    }, [extractText, textContainerRef]);
    useEffect(function () {
        if (pitch && utterThis) {
            utterThis.pitch = pitch;
        }
        if (volume && utterThis) {
            utterThis.volume = volume;
        }
        if (rate && utterThis) {
            utterThis.rate = rate;
        }
    }, [utterThis, pitch, volume, rate]);
    function speak() {
        if (synth && utterThis) {
            synth.speak(utterThis);
            setIsSpeaking(true);
        }
    }
    function pause() {
        if (synth) {
            synth.pause();
            setIsSpeaking(false);
        }
    }
    function resume() {
        if (synth) {
            synth.resume();
            setIsSpeaking(true);
        }
    }
    function setVoice(voiceName) {
        // find selected voice by its name
        if (utterThis)
            utterThis.voice = voices.find(function (item) { return item.name === voiceName; });
    }
    return {
        speak: speak,
        pause: pause,
        resume: resume,
        voices: voiceNames,
        setVoice: setVoice,
        ref: textContainerRef,
        utterance: utterThis,
        isSpeaking: isSpeaking
    };
};
export default useTextToVoice;
